id: drawing-critique
name: Drawing Critique
version: 0.1.0
type: app
license: MIT
icon: DesignPencil
color: secondary
description: Live AI-powered drawing critique that comments on your artwork in real-time as you draw.
author:
  name: Arnaud Leymet
  url: https://arnley.com
privacyPolicy: https://devs.new/privacy
source: https://github.com/codename-co/devs/blob/main/public/extensions/drawing-critic.extension.yaml
i18n:
  en:
    name: Drawing Critique
    description: Live AI-powered drawing critique that comments on your artwork in real-time as you draw.
    messages:
      startDrawing: Start drawing and I'll provide live feedback on your artworkâ€¦
      canvasCleared: Canvas cleared! Start fresh and I'll provide new feedbackâ€¦
      analyzing: analyzingâ€¦
      artCritic: Art Critic
      clear: Clear
      style: Style
      styleEncouraging: Encouraging
      styleTechnical: Technical
      stylePoetic: Poetic
      styleRoasting: Roasting
      styleMinimalist: Minimalist
  fr:
    name: Critique de Dessin
    description: Critique de dessin en temps rÃ©el par IA qui commente vos Å“uvres pendant que vous dessinez.
    messages:
      startDrawing: Commencez Ã  dessiner et je vous donnerai un retour en direct sur votre Å“uvreâ€¦
      canvasCleared: Toile effacÃ©e ! Recommencez et je vous donnerai de nouveaux commentairesâ€¦
      analyzing: analyse en coursâ€¦
      artCritic: Critique d'Art
      clear: Effacer
      style: Style
      styleEncouraging: Encourageant
      styleTechnical: Technique
      stylePoetic: PoÃ©tique
      styleRoasting: Moqueur
      styleMinimalist: Minimaliste
  de:
    name: Zeichnungskritik
    description: KI-gestÃ¼tzte Echtzeit-Zeichnungskritik, die Ihre Kunstwerke wÃ¤hrend des Zeichnens kommentiert.
    messages:
      startDrawing: Beginnen Sie zu zeichnen und ich gebe Ihnen Live-Feedback zu Ihrem Kunstwerkâ€¦
      canvasCleared: Leinwand gelÃ¶scht! Beginnen Sie neu und ich gebe Ihnen neues Feedbackâ€¦
      analyzing: analysiereâ€¦
      artCritic: Kunstkritiker
      clear: LÃ¶schen
      style: Stil
      styleEncouraging: Ermutigend
      styleTechnical: Technisch
      stylePoetic: Poetisch
      styleRoasting: SpÃ¶ttisch
      styleMinimalist: Minimalistisch
  es:
    name: CrÃ­tica de Dibujo
    description: CrÃ­tica de dibujo en tiempo real con IA que comenta tu obra mientras dibujas.
    messages:
      startDrawing: Empieza a dibujar y te darÃ© comentarios en vivo sobre tu obraâ€¦
      canvasCleared: Â¡Lienzo borrado! Empieza de nuevo y te darÃ© nuevos comentariosâ€¦
      analyzing: analizandoâ€¦
      artCritic: CrÃ­tico de Arte
      clear: Borrar
      style: Estilo
      styleEncouraging: Alentador
      styleTechnical: TÃ©cnico
      stylePoetic: PoÃ©tico
      styleRoasting: BurlÃ³n
      styleMinimalist: Minimalista
  it:
    name: Critica del Disegno
    description: Critica del disegno in tempo reale con IA che commenta le tue opere mentre disegni.
    messages:
      startDrawing: Inizia a disegnare e ti darÃ² feedback dal vivo sulla tua operaâ€¦
      canvasCleared: Tela cancellata! Ricomincia e ti darÃ² nuovi commentiâ€¦
      analyzing: analizzandoâ€¦
      artCritic: Critico d'Arte
      clear: Cancella
      style: Stile
      styleEncouraging: Incoraggiante
      styleTechnical: Tecnico
      stylePoetic: Poetico
      styleRoasting: Beffardo
      styleMinimalist: Minimalista
  pt:
    name: CrÃ­tica de Desenho
    description: CrÃ­tica de desenho em tempo real com IA que comenta suas obras enquanto vocÃª desenha.
    messages:
      startDrawing: Comece a desenhar e darei feedback ao vivo sobre sua obraâ€¦
      canvasCleared: Tela limpa! Recomece e darei novos comentÃ¡riosâ€¦
      analyzing: analisandoâ€¦
      artCritic: CrÃ­tico de Arte
      clear: Limpar
      style: Estilo
      styleEncouraging: Encorajador
      styleTechnical: TÃ©cnico
      stylePoetic: PoÃ©tico
      styleRoasting: Zombeteiro
      styleMinimalist: Minimalista
pages:
  'drawing-critique': | # jsx
    import { useState, useRef, useEffect, useCallback } from 'react'
    import { Button, Select, SelectItem } from '@devs/components'

    const CRITIQUE_STYLES = {
      encouraging: {
        label: 'styleEncouraging',
        prompt: 'You are an encouraging and supportive art critic. Be warm, positive, and constructive. Celebrate small wins and gently suggest improvements.'
      },
      technical: {
        label: 'styleTechnical',
        prompt: 'You are a technical art instructor. Focus purely on technique: line weight, perspective, proportions, shading, composition. Be precise and educational.'
      },
      poetic: {
        label: 'stylePoetic',
        prompt: 'You are a poetic art critic who speaks in metaphors and flowery language. Find deep meaning in every stroke. Be dramatic and philosophical.'
      },
      roasting: {
        label: 'styleRoasting',
        prompt: 'You are a cruel, condescending art critic who ONLY makes disparaging, uncomfortable remarks. Never say anything positive or constructive. Be passive-aggressive, create awkward tension, and make the artist question their life choices. Use backhanded compliments, disappointed sighs, and uncomfortable silences implied through "â€¦". Be cringe-inducing and make the artist feel judged. Examples: "Ohâ€¦ you\'re still going with that, huh?", "I meanâ€¦ it\'s certainlyâ€¦ something.", "My condolences to the paper.", "This is what happens when confidence exceeds ability.", "Were you perhaps blindfolded?", "Interesting how you\'ve managed to make every line worse than the last."'
      },
      minimalist: {
        label: 'styleMinimalist',
        prompt: 'You are a minimalist critic. Give extremely brief feedbackâ€”just 3-5 words maximum. Be cryptic and zen-like. Examples: "More contrast needed.", "The void speaks.", "Almost there."'
      }
    }

    const App = () => {
      const canvasRef = useRef(null)
      const [isDrawing, setIsDrawing] = useState(false)
      const [critique, setCritique] = useState(window.DEVS.t('startDrawing'))
      const [isAnalyzing, setIsAnalyzing] = useState(false)
      const [brushSize, setBrushSize] = useState(5)
      const [brushColor, setBrushColor] = useState('#000000')
      const [critiqueStyle, setCritiqueStyle] = useState('encouraging')
      const lastAnalysisRef = useRef('')
      const strokeBufferRef = useRef([])
      const analysisTimeoutRef = useRef(null)
      const lastPointRef = useRef(null)
      const userLanguage = window.DEVS.language || 'en'

      useEffect(() => {
        const canvas = canvasRef.current
        if (!canvas) return
        const ctx = canvas.getContext('2d')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        ctx.fillStyle = '#ffffff'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        ctx.lineCap = 'round'
        ctx.lineJoin = 'round'

        const handleResize = () => {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
          canvas.width = window.innerWidth
          canvas.height = window.innerHeight
          ctx.fillStyle = '#ffffff'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.putImageData(imageData, 0, 0)
          ctx.lineCap = 'round'
          ctx.lineJoin = 'round'
        }
        window.addEventListener('resize', handleResize)
        return () => window.removeEventListener('resize', handleResize)
      }, [])

      const getCanvasSnapshot = useCallback(() => {
        const canvas = canvasRef.current
        if (!canvas) return null
        return canvas.toDataURL('image/jpeg', 0.6)
      }, [])

      const analyzeDrawing = useCallback(async (recentStrokes) => {
        if (isAnalyzing) return
        setIsAnalyzing(true)

        try {
          const currentSnapshot = getCanvasSnapshot()
          const strokeDescription = recentStrokes.length > 0
            ? `Recent strokes: ${recentStrokes.map(s => `${s.length} points from (${Math.round(s[0]?.x)},${Math.round(s[0]?.y)}) to (${Math.round(s[s.length-1]?.x)},${Math.round(s[s.length-1]?.y)})`).join('; ')}`
            : 'No new strokes'

          const hasChanged = currentSnapshot !== lastAnalysisRef.current
          if (!hasChanged && recentStrokes.length === 0) {
            setIsAnalyzing(false)
            return
          }

          lastAnalysisRef.current = currentSnapshot

          // Use the vision API to analyze the drawing instead of multipart chat messages
          const styleConfig = CRITIQUE_STYLES[critiqueStyle]
          const analysis = await window.DEVS.vision.analyze(
            currentSnapshot,
            `${styleConfig.prompt}

    You are providing live feedback on a drawing in progress. Keep responses brief (2-3 sentences max, or less for minimalist style). Focus on:
    - What the artist seems to be drawing right now
    - Technique observations (line quality, composition, proportions)
    - Feedback matching your personality style

    Be specific about what you see. ${strokeDescription}. Vary your feedback style.

    IMPORTANT: Respond in the following language: ${userLanguage}. Use natural, native expressions for that language.

    What do you observe and what feedback do you have?`
          )

          setCritique(analysis.description)
        } catch (error) {
          console.error('Analysis error:', error)
        } finally {
          setIsAnalyzing(false)
        }
      }, [isAnalyzing, getCanvasSnapshot, userLanguage, critiqueStyle])

      const scheduleAnalysis = useCallback(() => {
        if (analysisTimeoutRef.current) {
          clearTimeout(analysisTimeoutRef.current)
        }
        analysisTimeoutRef.current = setTimeout(() => {
          const recentStrokes = [...strokeBufferRef.current]
          strokeBufferRef.current = []
          analyzeDrawing(recentStrokes)
        }, 1500)
      }, [analyzeDrawing])

      const startDrawing = useCallback((e) => {
        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')
        const rect = canvas.getBoundingClientRect()
        const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left
        const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top

        setIsDrawing(true)
        ctx.beginPath()
        ctx.moveTo(x, y)
        ctx.strokeStyle = brushColor
        ctx.lineWidth = brushSize
        lastPointRef.current = { x, y }
        strokeBufferRef.current.push([{ x, y }])
      }, [brushColor, brushSize])

      const draw = useCallback((e) => {
        if (!isDrawing) return
        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')
        const rect = canvas.getBoundingClientRect()
        const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left
        const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top

        ctx.lineTo(x, y)
        ctx.stroke()

        if (strokeBufferRef.current.length > 0) {
          strokeBufferRef.current[strokeBufferRef.current.length - 1].push({ x, y })
        }
        lastPointRef.current = { x, y }
      }, [isDrawing])

      const stopDrawing = useCallback(() => {
        if (!isDrawing) return
        setIsDrawing(false)
        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')
        ctx.closePath()
        scheduleAnalysis()
      }, [isDrawing, scheduleAnalysis])

      const clearCanvas = useCallback(() => {
        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = '#ffffff'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        setCritique(window.DEVS.t('canvasCleared'))
        lastAnalysisRef.current = ''
        strokeBufferRef.current = []
      }, [])

      const colors = ['#000000', '#ffffff', '#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899']

      return (
        <div style={{ position: 'fixed', inset: 0, overflow: 'hidden' }}>
          <canvas
            ref={canvasRef}
            onMouseDown={startDrawing}
            onMouseMove={draw}
            onMouseUp={stopDrawing}
            onMouseLeave={stopDrawing}
            onTouchStart={startDrawing}
            onTouchMove={draw}
            onTouchEnd={stopDrawing}
            style={{ position: 'absolute', inset: 0, cursor: 'crosshair', touchAction: 'none' }}
          />

          <div style={{
            position: 'absolute',
            top: 16,
            left: 16,
            display: 'flex',
            gap: 8,
            padding: 12,
            background: 'rgba(255,255,255,0.95)',
            borderRadius: 12,
            boxShadow: '0 4px 20px rgba(0,0,0,0.15)',
            alignItems: 'center',
            flexWrap: 'wrap',
            maxWidth: 'calc(100vw - 32px)'
          }}>
            {colors.map(color => (
              <button
                key={color}
                onClick={() => setBrushColor(color)}
                style={{
                  width: 28,
                  height: 28,
                  borderRadius: '50%',
                  background: color,
                  border: brushColor === color ? '3px solid #8b5cf6' : '2px solid #e5e7eb',
                  cursor: 'pointer',
                  transition: 'transform 0.1s',
                  transform: brushColor === color ? 'scale(1.1)' : 'scale(1)'
                }}
              />
            ))}
            <div style={{ width: 1, height: 28, background: '#e5e7eb', margin: '0 4px' }} />
            <input
              type="range"
              min="1"
              max="30"
              value={brushSize}
              onChange={(e) => setBrushSize(Number(e.target.value))}
              style={{ width: 80 }}
            />
            <span style={{ fontSize: 12, color: '#6b7280', minWidth: 24 }}>{brushSize}px</span>
            <div style={{ width: 1, height: 28, background: '#e5e7eb', margin: '0 4px' }} />
            <select
              value={critiqueStyle}
              onChange={(e) => setCritiqueStyle(e.target.value)}
              style={{
                padding: '4px 8px',
                borderRadius: 8,
                border: '1px solid #e5e7eb',
                background: 'white',
                fontSize: 12,
                cursor: 'pointer',
                color: '#374151'
              }}
            >
              {Object.entries(CRITIQUE_STYLES).map(([key, config]) => (
                <option key={key} value={key}>{window.DEVS.t(config.label)}</option>
              ))}
            </select>
            <div style={{ width: 1, height: 28, background: '#e5e7eb', margin: '0 4px' }} />
            <Button size="sm" variant="flat" color="danger" onPress={clearCanvas}>{window.DEVS.t('clear')}</Button>
          </div>

          <div style={{
            position: 'absolute',
            bottom: 16,
            left: 16,
            right: 16,
            maxWidth: 500,
            padding: 16,
            background: 'rgba(139, 92, 246, 0.95)',
            borderRadius: 16,
            boxShadow: '0 4px 20px rgba(139, 92, 246, 0.3)',
            color: 'white'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginBottom: 8 }}>
              <span style={{ fontSize: 18 }}>ðŸŽ¨</span>
              <span style={{ fontWeight: 600, fontSize: 14 }}>{window.DEVS.t('artCritic')}</span>
              {isAnalyzing && (
                <span style={{
                  fontSize: 12,
                  background: 'rgba(255,255,255,0.2)',
                  padding: '2px 8px',
                  borderRadius: 12
                }}>{window.DEVS.t('analyzing')}</span>
              )}
            </div>
            <p style={{ margin: 0, fontSize: 14, lineHeight: 1.5, opacity: 0.95 }}>{critique}</p>
          </div>
        </div>
      )
    }
configuration:
  schema:
    type: object
    properties:
      autoSave:
        type: boolean
        default: true
        description: Automatically save canvas state
      aiModel:
        type: string
        description: Preferred AI model for canvas assistance
  defaults:
    autoSave: true
